#!/usr/bin/env python3
"""
Backend Security Scanner
Detecta vulnerabilidades em c√≥digo backend antes do commit
"""

import re
import sys
from pathlib import Path
from typing import List, Dict, Tuple
import json

class BackendSecurityScanner:
    """Scanner de seguran√ßa para c√≥digo backend"""

    # Padr√µes de risco
    SECURITY_PATTERNS = {
        'hardcoded_secret': [
            r'api[_-]?key\s*=\s*["\'][^"\']{20,}["\']',
            r'password\s*=\s*["\'][^"\']+["\']',
            r'secret\s*=\s*["\'][^"\']{20,}["\']',
            r'token\s*=\s*["\'][^"\']{20,}["\']',
        ],
        'sql_injection': [
            r'execute\([^)]*\+[^)]*\)',  # String concatenation in query
            r'query\([^)]*`[^`]*\$\{[^}]+\}',  # Template literals in queries
            r'SELECT.*WHERE.*=.*\+',  # Concatenation in WHERE
        ],
        'command_injection': [
            r'exec\([^)]*\+[^)]*\)',
            r'spawn\([^)]*\+[^)]*\)',
            r'eval\(',
        ],
        'weak_crypto': [
            r'createHash\(["\']md5["\']\)',
            r'createHash\(["\']sha1["\']\)',
            r'randomBytes\(4\)',  # Too few random bytes
        ],
        'missing_validation': [
            r'req\.(body|params|query)\.[a-zA-Z]+(?!.*z\.)',  # Acesso direto sem Zod
        ],
        'debug_code': [
            r'console\.log\(',
            r'console\.debug\(',
            r'debugger;',
        ],
    }

    # Padr√µes de configura√ß√£o insegura
    CONFIG_RISKS = {
        'cors_wildcard': r'cors\(\s*\{\s*origin:\s*["\*]',
        'ssl_disabled': r'rejectUnauthorized:\s*false',
        'debug_enabled': r'NODE_ENV.*development',
    }

    def __init__(self, filepath: Path):
        self.filepath = filepath
        self.content = filepath.read_text()
        self.violations: List[Dict] = []

    def check_hardcoded_secrets(self) -> List[Tuple[int, str, str]]:
        """Detecta secrets hardcodados"""
        violations = []
        for i, line in enumerate(self.content.split('\n'), 1):
            # Skip comments
            if line.strip().startswith('//') or line.strip().startswith('#'):
                continue

            for pattern in self.SECURITY_PATTERNS['hardcoded_secret']:
                if re.search(pattern, line, re.IGNORECASE):
                    violations.append((i, 'HARDCODED_SECRET', line.strip()[:60]))
        return violations

    def check_sql_injection(self) -> List[Tuple[int, str, str]]:
        """Detecta riscos de SQL injection"""
        violations = []
        for i, line in enumerate(self.content.split('\n'), 1):
            for pattern in self.SECURITY_PATTERNS['sql_injection']:
                if re.search(pattern, line):
                    violations.append((i, 'SQL_INJECTION_RISK', 'String concatenation in query'))
        return violations

    def check_input_validation(self) -> List[Tuple[int, str, str]]:
        """Detecta falta de valida√ß√£o de input"""
        violations = []
        lines = self.content.split('\n')

        for i, line in enumerate(lines, 1):
            # Procura acesso direto a req.body/params/query
            if re.search(r'req\.(body|params|query)\.', line):
                # Verifica se tem valida√ß√£o Zod nas linhas pr√≥ximas
                context = '\n'.join(lines[max(0, i-5):min(len(lines), i+5)])
                if not re.search(r'z\.(object|string|number|array)', context):
                    violations.append((i, 'MISSING_VALIDATION', 'Direct access without Zod validation'))

        return violations

    def check_rate_limiting(self) -> bool:
        """Verifica se rate limiting est√° configurado"""
        has_rate_limit = bool(re.search(r'rateLimit|express-rate-limit', self.content))
        return has_rate_limit

    def check_security_headers(self) -> bool:
        """Verifica se helmet est√° configurado"""
        has_helmet = bool(re.search(r'helmet\(\)', self.content))
        return has_helmet

    def check_jwt_secret_strength(self) -> List[Tuple[int, str, str]]:
        """Verifica for√ßa do JWT secret"""
        violations = []
        matches = re.finditer(r'jwt.*secret.*["\']([^"\']+)["\']', self.content, re.IGNORECASE)

        for match in matches:
            secret = match.group(1)
            line_num = self.content[:match.start()].count('\n') + 1

            if len(secret) < 32:
                violations.append((line_num, 'WEAK_JWT_SECRET', f'Secret too short: {len(secret)} chars'))

        return violations

    def run(self) -> Dict:
        """Executa todas as verifica√ß√µes"""
        results = {
            'file': str(self.filepath),
            'passed': True,
            'critical': [],
            'high': [],
            'medium': [],
            'info': []
        }

        # CRITICAL: Hardcoded secrets
        secret_violations = self.check_hardcoded_secrets()
        if secret_violations:
            results['passed'] = False
            for line, vtype, msg in secret_violations:
                results['critical'].append({
                    'line': line,
                    'type': vtype,
                    'message': msg
                })

        # CRITICAL: SQL Injection
        sql_violations = self.check_sql_injection()
        if sql_violations:
            results['passed'] = False
            for line, vtype, msg in sql_violations:
                results['critical'].append({
                    'line': line,
                    'type': vtype,
                    'message': msg
                })

        # HIGH: Missing input validation
        validation_violations = self.check_input_validation()
        if validation_violations:
            results['passed'] = False
            for line, vtype, msg in validation_violations:
                results['high'].append({
                    'line': line,
                    'type': vtype,
                    'message': msg
                })

        # HIGH: Weak JWT
        jwt_violations = self.check_jwt_secret_strength()
        if jwt_violations:
            results['passed'] = False
            for line, vtype, msg in jwt_violations:
                results['high'].append({
                    'line': line,
                    'type': vtype,
                    'message': msg
                })

        # MEDIUM: Missing rate limiting
        if not self.check_rate_limiting():
            results['medium'].append({
                'line': 0,
                'type': 'MISSING_RATE_LIMIT',
                'message': 'No rate limiting configured'
            })

        # MEDIUM: Missing security headers
        if not self.check_security_headers():
            results['medium'].append({
                'line': 0,
                'type': 'MISSING_HELMET',
                'message': 'Helmet.js not configured'
            })

        return results

def main():
    if len(sys.argv) < 2:
        print("Usage: backend_security_scan.py <file.ts>")
        sys.exit(1)

    filepath = Path(sys.argv[1])
    if not filepath.exists():
        print(f"‚ùå File not found: {filepath}")
        sys.exit(1)

    scanner = BackendSecurityScanner(filepath)
    results = scanner.run()

    print(f"\nüîí Security Scan: {filepath.name}")
    print("=" * 60)

    if results['critical']:
        print("\nüî¥ CRITICAL ISSUES:")
        for v in results['critical']:
            print(f"   Line {v['line']}: [{v['type']}] {v['message']}")

    if results['high']:
        print("\nüü† HIGH SEVERITY:")
        for v in results['high']:
            print(f"   Line {v['line']}: [{v['type']}] {v['message']}")

    if results['medium']:
        print("\nüü° MEDIUM SEVERITY:")
        for v in results['medium']:
            if v['line'] > 0:
                print(f"   Line {v['line']}: [{v['type']}] {v['message']}")
            else:
                print(f"   [{v['type']}] {v['message']}")

    if results['passed']:
        print("\n‚úÖ No critical security issues found")
        sys.exit(0)
    else:
        print("\n‚ùå Security issues detected - fix before committing")
        sys.exit(1)

if __name__ == '__main__':
    main()
